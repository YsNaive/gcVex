{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor R_Motor = motor(PORT7, false);\nmotor L_Motor = motor(PORT12, true);\ntouchled TouchLED2 = touchled(PORT2);\nmotor up_down = motor(PORT8, true);\nmotor claw = motor(PORT6, false);\nmotor turn1 = motor(PORT5, false);\nmotor turn2 = motor(PORT11, true);\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n//大陸GYRO_PID_turn\n\nint sgn(double d)\n{\n  if (d<0) return -1;\n  else if (d==0) return 0;\n  else return 1;\n}\n\n\n\nvoid turn_gyro(float target)\n{\n  float kp = 0.5;\n  float ki = 0.005;\n  float kd = 0.001;\n  float irange = 1.0;\n  float istart = 60;\n  float dtol = 2;\n  float errortolerance = 1;\n  float lim = 100;\n  float error = target - BrainInertial.rotation(degrees);\n  float lasterror;float v = 0;float i = 0;\n  bool arrived;\n  float pow;\n  lasterror = error;\n  arrived = error == 0;\n  while (!arrived)\n  {\n\n    error = target - BrainInertial.rotation(degrees);\n    v = error - lasterror;\n    lasterror = error;\n    if ((fabs(error) < errortolerance && fabs(v) <= dtol)){arrived = true;}\n    if (fabs(i) < irange && fabs(error) < istart)\n      i += sgn(error) * 0.01;\n    if (error * lasterror <= 0)\n      i = 0;\n    pow = kp * error + kd * v + ki * i;\n    pow = fabs(pow) > lim ? sgn(pow) * lim : pow;\n    L_Motor.setVelocity(pow, percent);\n    R_Motor.setVelocity(-pow, percent);\n    L_Motor.spin(forward);\n    R_Motor.spin(forward);\n\n    wait(10, msec);\n    printf(\"%d\\n\",arrived);\n\n\n  }\n    L_Motor.setVelocity(0, percent);\n    R_Motor.setVelocity(0, percent);\n}\n\n\n//算pd修正值\nfloat pd_a;\nfloat pd_b;\nfloat error_now;\nfloat error_past;\nfloat Kp=0.4;\nfloat Kd=0.07;\n\nvoid PD_value(float a,float b,float basic_power,float P,float D){\n  error_now =a-b;\n  error_past =0;\n  float pd_error=error_now*P+(error_now-error_past)*D;\n  if (basic_power>0){\n    pd_a=basic_power+pd_error;\n    pd_b=basic_power-pd_error;\n  }\n  else {\n    pd_a=basic_power-pd_error;\n    pd_b=basic_power+pd_error;\n  }\n  float lim=100;\n  if (pd_a > lim) {\n   pd_b=pd_b-(pd_a-100);\n   pd_a=lim;\n  }  \n  if (pd_b > lim) {\n   pd_a=pd_a-(pd_b-100);\n   pd_b=lim;\n  }  \n  if (pd_a < (lim*-1)){\n   pd_b=pd_b-(pd_a+100);\n   pd_a=lim*(-1);\n  }  \n  if (pd_b < (lim*-1)){\n   pd_a=pd_a-(pd_b+100);\n   pd_b=lim*(-1);\n  }\nerror_past =error_now;\nwait(10, msec);\n\n}\n\n//算緩加acc 電力\nfloat up_Frist_function(float x,float P,float D){   //P是緩加最大電力，D是緩加角度\n float y=-((((7/8*P)-5)*81)/((25*D*D)))*((x-((5/9)*D))*(x-(5/9*D)))+(7/8*P);\n return y;\n}\n\nfloat up_Second_function(float x,float P,float D){   \n float y=-((((7*P/8)-5)*4)/(25*D*D)+(49*P)/(128*D*D))*((x-D)*(x-D))+P;\n return y;\n}\n\nfloat down_Frist_function(float x,float P,float D){                    //P是緩加最大電力，D是緩加角度，P小於0\n float y=-((((7*P/8)+5)*81)/(25*D*D))*(x-(5/9*D))*(x-(5/9*D))+7/8*P;\n return y;\n}\n\nfloat down_Second_function(float x,float P,float D){   \n float y=-((((7*P/8)+5)*4)/(25*D*D)+(49*P)/(128*D*D))*(x-D)*(x-D)+P;\n return y;\n}\nfloat acc_value(float x,float P,float D1,float D2,float all){    //P是緩加最大電力，D1是緩加角度，D2緩減角度，x是現在走的角度，要是正的\n  float y=0;\n  float error=all-x;\n  float last_error=0;\n  if (P>0) {  //前進\n   if (x<=(3/7*D1)) {\n      y=up_Frist_function(x,P,D1)+4;\n    }\n   if ((3/7*D1)<x && x<=D1) {\n      y=up_Second_function(x,P,D1);\n    }\n   if (D1<x && x<=(all-D2)) {\n      y=P;\n    }    \n   if ((all-D2)<x && x<=(all-(3/7*D2))) {\n      y=up_Second_function((all-x),P,D2);\n    } \n   if ((all-(3/7*D2))<x && x<=(all-65)) {\n      y=up_Frist_function((all-x),P,D2);\n    }\n   if (x>=(all-65)){\n      //pid算電力\n      y=(all-x)*0.4+(error-last_error)*0.08;     //要再調\n    } \n    if(D1==0){\n      y=P;\n    }\n    if(D2==0){\n      y=P;\n    }\n    if(y>P){\n      y=P;\n    }\n  }                \n  else {   //後退\n    if (x<=(3/7*D1)) {\n      y=down_Frist_function(x,P,D1)-4;\n    }\n   if ((3/7*D1)<x && x<=D1) {\n      y=down_Second_function(x,P,D1);\n    }\n   if (D1<x && x<=(all-D2)) {\n      y=P;\n    }    \n   if ((all-D2)<x && x<=(all-(3/7*D2))) {\n      y=down_Second_function((all-x),P,D2);\n    } \n   if ((all-(3/7*D2))<x && x<=(all-65)) {\n      y=down_Frist_function((all-x),P,D2);\n    }\n   if (x>=(all-65)){\n      //pid算電力\n      y=(all-x)*0.4+(error-last_error)*0.08;     //要再調\n    } \n    if(D1==0){\n      y=P;\n    }\n    if(D2==0){\n      y=P;\n    }\n    if(y<P){\n      y=P;\n    }\n  }\nlast_error=error;\n //wait(10, msec);\nreturn y;\n}\n                                                  //緩加角度        緩減角度\nvoid line_deg_move(float degree,float power,float acc_up_deg,float acc_down_deg,bool stop_orNot){\n  R_Motor.setPosition(0, degrees);\n  L_Motor.setPosition(0, degrees);\n  bool arrived=false;\n  float start_deg=BrainInertial.rotation(degrees);\n  float now_power;\n  float now_degree=0;\n  float now_degree_error= degree-now_degree;\n  float past_degree_error=0;\n  float v=now_degree_error-past_degree_error;\n  while(!arrived){\n    if ((fabs(now_degree_error) < 1.0 )&& (fabs(v)<=2.0)){arrived=true;}\n    if(acc_down_deg==0){\n      if(now_degree>=degree){arrived=true;}\n    }\n   v=now_degree_error-past_degree_error;\n   now_degree_error= degree-now_degree;\n   now_degree=(fabs(L_Motor.position(degrees))+fabs(R_Motor.position(degrees)))/2;\n   now_power= acc_value(now_degree,power,acc_up_deg,acc_down_deg,degree);\n   PD_value(BrainInertial.rotation(degrees),start_deg,now_power,Kp,Kd);//PD_value(R_Motor.position(degrees),L_Motor.position(degrees),now_power,Kp,Kd);\n   L_Motor.setVelocity(pd_a, percent);\n   R_Motor.setVelocity(pd_b, percent);\n   L_Motor.spin(forward);\n   R_Motor.spin(forward);\n   printf(\"%f//%f//%f\\n\",now_power,now_degree,(R_Motor.position(degrees)-L_Motor.position(degrees)));\n  }\n  if(stop_orNot){\n   L_Motor.setStopping(hold);\n   R_Motor.setStopping(hold);\n  }\n  else{\n   L_Motor.setStopping(coast);\n   R_Motor.setStopping(coast);\n  }\n  L_Motor.stop();\n  R_Motor.stop();\n}\nvoid line_time_move(float power,float time,bool pd_orNot){\n  Brain.Timer.reset();\n  R_Motor.setPosition(0, degrees);\n  L_Motor.setPosition(0, degrees);\n  L_Motor.setStopping(coast);\n  R_Motor.setStopping(coast);\n  float start_deg=BrainInertial.rotation(degrees);\n\n  if(pd_orNot){\n   while(Brain.Timer.value()<time){\n    PD_value(BrainInertial.rotation(degrees),start_deg,power,Kp,Kd);//PD_value(R_Motor.position(degrees),L_Motor.position(degrees),power,Kp,Kd);\n    L_Motor.setVelocity(pd_a, percent);\n    R_Motor.setVelocity(pd_b, percent);\n    L_Motor.spin(forward);\n    R_Motor.spin(forward);\n   }\n   L_Motor.stop();\n   R_Motor.stop();\n  }\n  else{\n    while(Brain.Timer.value()<time){\n    L_Motor.setVelocity(power, percent);\n    R_Motor.setVelocity(power, percent);\n    L_Motor.spin(forward);\n    R_Motor.spin(forward);\n   }\n   L_Motor.stop();\n   R_Motor.stop();\n  }\n}\n\nint getGyroDegree(){\n  while(1){\n    printf(\"gyroDeg：%f\\n\",BrainInertial.heading(degrees));\n    wait(5, msec);\n  }\n  return 0;\n}\n\n//出發設置\nvoid setup(){\n  up_down.setVelocity(70, percent);\n  claw.setVelocity(100, percent);\n  claw.spin(reverse);\n  up_down.spin(reverse);\n  wait(2, seconds);\n  claw.setPosition(0, degrees);\n  up_down.setPosition(0, degrees);\n  up_down.spinToPosition(250, degrees,false);\n  claw.spinToPosition(430, degrees);\n}\n\n//射盤\n\nvoid put_plate(){\n  turn1.setVelocity(70, percent);\n  turn2.setVelocity(70, percent);\n  up_down.spin(forward);\n  wait(1.5, seconds);\n  up_down.spinToPosition(170, degrees);\n  up_down.spin(forward);\n  wait(1.5, seconds);\n  up_down.spinToPosition(230, degrees);\n  claw.spinToPosition(0, degrees,false);\n  while(!TouchLED2.pressing()){\n    up_down.spin(forward);\n    wait(1.5, seconds);\n  }\n  up_down.spinToPosition(250, degrees,false);\n  claw.spinToPosition(430, degrees,false);\n  turn1.stop();\n  turn2.stop();\n  wait(0.1, seconds);\n  TouchLED2.setColor(colorType::none);\n}\n\n//turn purple\nvoid turn_purple(float time){\n  up_down.spinToPosition(280, degrees,false);\n  turn1.setVelocity(100, percent);\n  turn2.setVelocity(100, percent);\n  turn1.spin(forward);\n  turn2.spin(forward);\n  R_Motor.setVelocity(15, percent);\n  L_Motor.setVelocity(30, percent);\n  R_Motor.spin(reverse);\n  L_Motor.spin(reverse);\n  wait(time, seconds);\n  turn1.stop();\n  turn2.stop();\n  R_Motor.stop();\n  L_Motor.stop();\n}\n\n\n//左邊藍塔加紫塔\nvoid Left_blue_purple(){\n line_deg_move(310,50,70,70,true);\n turn_gyro(-27);\n line_deg_move(310,50,70,70,true);\n turn_gyro(0);\n line_time_move(-50,0.7,true);\n claw.setTimeout(5, seconds);\n claw.spinToPosition(650, degrees);\n wait(0.5, seconds);\n claw.spinToPosition(430, degrees);\n line_deg_move(50,30,0,0,true);\n turn_gyro(-95);\n line_time_move(-50,0.5,false);\n turn_purple(5);\n line_deg_move(200,50,70,70,true);\n turn_gyro(0);\n turn1.spin(forward);\n turn1.spin(forward);\n line_time_move(50,0.7,true);\n put_plate();\n}\n\n\n\n\nint main() {\n  vex::task ws1(getGyroDegree);\n  // Kp=0.4;\n  // Kd=0.07;\n  // BrainInertial.calibrate();\n  // setup();\n  // TouchLED2.setColor(colorType::green);\n  // TouchLED2.pressed(Left_blue_purple);\n\n  \n  \n  \n}\n","textLanguage":"cpp","rconfig":[{"port":[7],"name":"R_Motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"向後"},"triportSourcePort":22},{"port":[12],"name":"L_Motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"向後"},"triportSourcePort":22},{"port":[2],"name":"TouchLED2","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[8],"name":"up_down","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"向後"},"triportSourcePort":22},{"port":[6],"name":"claw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"向後"},"triportSourcePort":22},{"port":[5],"name":"turn1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"向後"},"triportSourcePort":22},{"port":[11],"name":"turn2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"向後"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.4","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}